# G08 Graph Theory: DFAs, NFAs, and Regular Languages



* [Skill Description](#skill-description)
* [Sample Problems](#Sample-Problems)
* [Skill Tutorial](#Tutorial)
* [Answers to Sample Problems](#Answers)
* [Further Reading](#Reading)

---


# Skill Definition




---

# Sample-Problems

## Problem 1
Draw a DFA that accepts the following strings:
```
cs10 cs12 cs21 cs29 cs121 cs130 cs131 cs150
```

## Problem 2.
What is the Regular Expression corresponding to the following NFA:

![nfa1a](nfa1a.png)


---

# Tutorial

## Labelled graphs
Sometimes we label the edges of a digraph.

## Finite State Machines aka Deterministic Finite Automata
A good example of a digraph is a finite state machine which is used to define "regular expressions" that can easily
be recognized by computer programs. We'll give some examples in class. The edges of a DFA are labelled with characters from some alphabet. One of the nodes is identified as the start state, and one or more nodes are final states. A string of characters
is accepted by the DFA if it can be generated by a character labels on a path starting at the start state and ending in a final state.

Here is an example of a DFA that will accept binary numbers with an even number of 1's.
![dfa1](dfa1.png)

For example, here is a path that accepts the string 00101100010

|char | |0| |0| |1 ||0| |1| |1| |0| |0| |0| |1| |0| |
|-    |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|state|1| |1| |1| |2| |2| |1| |2| |2| |2| |2| |1| |1|


## Non-deterministic Finite Automata
We can create a more general finite state machine where allow multiple edges out of a node to have the same label.
We say that a string is accepted by the NFA is there is some path which is labelled by the characters of that string.

### NFA example 1
Here is an example of an NFA accepting some subset of binary numbers:

![nfa1a](nfa1a.png)

and here is a trace that shows it accepts the string 0111011
|char | |0| |1| |1| |1| |0| |1| |0| |
|-    |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|state|1| |2| |2| |2| |2 ||4| |4| |6|

It can be tricky trying to see if an NFA accepts a given string because there are so many possible paths to consider,
but it turns out that every NFA can be converted into a DFA where the nodes of the DFA are sets of NFA nodes that
represent all of the possible states one can be in after following any path leading to that node....

Here is the DFA generated from the NFA above

![nfa1a](nfa1b.png)

and we can see how it accepts that same string

|char | |0|  |1|   |1|   |1|   |0|  |1| |0| |
|-    |-|-|- |-|-  |-|-  |-|-  |-|- |-|-|-|-|
|state|1| |23| |235| |235| |235| |46| |4| |6|


## Regular Expressions

We won't go into detail about it in this class, but NFAs and DFAs are very useful when writing compilers (programs that
convert high level languages into machine code). They are used for defining and recognizing the lexical tokens of a
programming language (i.e. the "words" of the language). There is another equivalent way of specifying NFAs using
regular expression notation. These expressions combine the characters of the language being recognized with some operators
* E = a character
* E = F G   (meaning its an F followed by a G)
* E = F*  (meaning 0 or more Fs)
* E = F+G (meaning an F or a G)

So the regular expression corresponding to the following DFA, 
![dfa1](dfa1.png)
accepting binary strings with an even number of 1s, is

```
0*(10*10*)*
```


---
---

# Answers

## Problem 1
Draw a DFA that accepts the following strings:
```
cs10 cs12 cs21 cs29 cs121 cs130 cs131 cs150
```
Here is the DFA. This kind of a structure is also called a "Trie" as it provides a very fast way
of checking to see if a string is in a set of strings..

![cs_trie](cs_trie.png)


## Problem 2
What is the Regular Expression corresponding to the following NFA:

![nfa1a](nfa1a.png)

The  regular expression for this NFA is 
```
(01*01*0)+(01*10)
```
which defines the set of binary strings of length 3 or more that start and end with 0 and contain at most one other 0.


---
