# F26 Graph Theory: Basic Properties


* [Skill Description](#skill-description)
* [Sample Problems](#Sample-Problems)
* [Skill Tutorial](#Tutorial)
* [Answers to Sample Problems](#Answers)
* [Further Reading](#Reading)

---


# Skill Definition




---

# Sample-Problems

## Problem 1


## Problem 2.


---

# Tutorial


## Directed Graphs

A **directed graph (or digraph)** $G$ is a pair $(V,E)$ where $V$ is a set of vertices or nodes, and $E$ is a subset of $V \times V$ called the edges of $G$.
We can draw a 2d visual representation of a graph by plotting each of the points $v$ of $V$ as distinct point $p(v)$ on the x-y plane and then
for each edge $(a,b)$ in $E$ draw a line between the points $p(a)$ and $p(b)$, usually with an arrow at the end point to $b$. 

We say that the the edge $d=(a,b)$ goes from $a$ to $b$,
* $a$ is the tail of $e$
* $b$ is the head of $b$

## Digraphs are another way of thinking about Binary Relations
We can easily create a digraph from a relation R on $A\times B$ by letting $V= A\cup B$ and letting $E = \\{(a\rightarrow b) ir aRb\\}$

Likewise, given a digraph $(V,E)$ we can create a binary relation $R:V\rightarrow V$ where $aRb \equiv (a,b)\in E$

## Labelled graphs
Sometimes we label the edges and/or vertices of a digraph. 

## Directed Acyclic Graphs
A graph without any cycles is called a **directed acyclic graph** or **DAG**


## Factoring a digraph
Any directed graph can be factored into a DAG whose elements are equivalence classes of the relation
defined by $a\equiv b$ if there is a path from a to b and vice versa.

**Digraph Factoring Skill**
We will have you practice factoring a digraph into a set of equivalence classes with a DAG ontop of those equivalence classes.

## Finite State Machines aka Deterministic Finite Automata
a good example of a digraph is a finite state machine which is used to define "regular expressions" that can easily
be recognized by computer programs. We'll give some examples in class.

**DFA Skill** - determine a DFA for some set of strings and/or determine if a string is accepted by a particular DFA

## Non-deterministic Finite Automata
We can create a more general finite state machine where allow multiple edges out of a node to have the same label.
Given an NFA with states S we can create a DFA whose states are a subset of P(S) 

# Representing Digraphs
The simplest way to represent a digraph is as a 2d table of integer values where
* the ith row and jth column contains $1$ if there is an edge from vertex $i$ to vertex $j$
* otherwise there it contains $0$

This table is called the adjacency matrix.

For a very large matrix it is better to just have a list of adjacent vertices for each vertex.

# Paths in a digraph
It turns out that there is a nice way to calculate the number of paths between each pair of vertices using
the adjacency matrix.  Let $A$ be the adjacency matrix for a graph G with nodes $\\{1,2,\ldots,n\\}$, then
* the entry in A for the ith row and jth column is denoted $A_{ij}$
* this is the number of paths from $i$ to $j$ of length 1

To calculate the number of paths of length 2 between $i$ and $j$ we need to count the number of nodes $k$ for which
there is a path from $i$ to $k$ and from $k$ to $j$.  If we let $A^2$ be the matrix whose $ij$ th entry is the number of paths from $i$ to $j$ of length 2, then
* $A^2_{ij} = \sum_\limits{k-1}^n A_{ik} * A_{kj}$

Notice that this will take $n^3$ multiplications to find all of $n^2$ entries in the matrix $A^2$.

and this is exactly the definition of the matrix multiplication of $A$ with itself!

## Matrix Multiplication
If $A$ is a rxs matrix and $B$ is a sxt matrix, then $A * B$ is the matrix $C$ whose entries are
* $C_{ij} = \sum_\limits{k=1}^s A_{ik}*B_{kj}$

Visually we multiply the $i$ th row by the $k$ th column, by multiplying the corresponding elements (1st 2nd 3rd ..)
and summing those products. Here is an example:

```
1 1 0        1 0 0       2 1 0
0 0 1    *   1 1 0  =    1 1 1
1 0 0        1 1 1       1 0 0
```
For example, multiplying the 1st row of A by the 2nd column of B gives 
* $(1 1 0) * (0 1 1) = 1 * 0 + 1 * 1 + 0 * 1 = 1$

## Reachability and Transitive Closure

We can use a similar approach if we want to find whether node i is reachable from node j.

If we defined the relation $a\prec b$ to mean b is reachable from a, then it is clear this
is a partial order (i.e. it is transitive), but it may not be a strict partial order. We
can compute this relation using a kind of matrix multiplication... 

The reachability relation for a partial order is called the transitive closure of that partial order. Given the adjacency matrix of a partial order, we would like to compute the adjacency
matrix of the transitive closure relatively quickly....

To do this, we can use an adjacency matrix with Boolean values, were 
* $A_{ij}=T$ if i=j or if there is an edge from i to j and
* $A_{ij}=F$ otherwise

To see if there is a path from $i$ to $j$ of length 2, we would use the following calculation
* $A^2_{ij} = \bigvee_\limits{k=1}^n A_{ik}\wedge A_{kj}$

This is just matrix multiplication but using $\vee$ for addition and $\wedge$ for multiplication.

Calculating this boolean matrix requires about $n^3$ conjunctions and disjunctions.

Similarly, we can use the same approach to calculate $(A^2)^2=A^{2^2}$ which will take anohter $n^3$ steps

Continuing $k$ times we can calculate $B = A^{2^k}$ in $kn^3$ steps 
and this will be matrix where $B_{ij}=T$ if there is apath from $i$ to $j$ of length $2^k$ or less.

If the graph contains $n$ nodes, then if there is a path from $i$ to $j$, then there is a path with length
at most $n$ (Prove it!)

This implies that if we compute $B=A^{2^k}$ for $2^k\ge n$,
then $B_{ij}=T$ if and only if there is a path from $i$ to $j$ of any length.

Since $2^k\ge n$ if and only if $k \ge \log_2(n)$, this means we can compute the reachability matrix for the graph $G$
in time $n \log_2(n)$ by repeatedly squaring the matrix $A$ $\log_2(n)$ times.



---
---

# Answers

## Problem 1

## Problem 2


---
